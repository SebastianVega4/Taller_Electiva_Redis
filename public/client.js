const socket = io();

// Configuraci√≥n de gr√°ficos
const charts = {
  temperatura: null,
  humedad: null,
  presion: null,
  viento: null
};

// Colores para diferentes sensores
const coloresSensores = {
  'Bogot√°': '#FF6B6B',
  'Medell√≠n': '#4ECDC4',
  'Cali': '#45B7D1',
  'Barranquilla': '#96CEB4',
  'Cartagena': '#FFEAA7',
  'Tunja': '#A29BFE',
  'Duitama': '#FD79A8',
  'Sogamoso': '#55EFC4',
  'Yopal': '#FDCB6E',
  'Aguazul': '#74B9FF'
};

// Datos en memoria del cliente
const datosCliente = {
  metricasActuales: {},
  historico: {
    temperatura: [],
    humedad: [],
    presion: [],
    viento: []
  }
};

// Bandera para verificar si los gr√°ficos est√°n listos
let graficosListos = false;

// Destruir gr√°ficos existentes
function destruirGraficos() {
  Object.keys(charts).forEach(tipo => {
    if (charts[tipo]) {
      charts[tipo].destroy();
      charts[tipo] = null;
    }
  });
  graficosListos = false;
  console.log('üóëÔ∏è Gr√°ficos destruidos');
}

// Inicializar gr√°ficos - VERSI√ìN MEJORADA Y SIMPLIFICADA
function inicializarGraficos() {
  console.log('üîÑ Iniciando inicializaci√≥n de gr√°ficos...');
  
  // Destruir gr√°ficos existentes primero
  destruirGraficos();

  try {
    // Verificar que los elementos canvas existan
    const canvasIds = ['chartTemperatura', 'chartHumedad', 'chartPresion', 'chartViento'];
    let todosLosCanvasExisten = true;
    
    for (const canvasId of canvasIds) {
      const canvas = document.getElementById(canvasId);
      if (!canvas) {
        console.error(`‚ùå No se encontr√≥ el canvas: ${canvasId}`);
        todosLosCanvasExisten = false;
        break;
      }
      console.log(`‚úÖ Canvas encontrado: ${canvasId}`);
    }

    if (!todosLosCanvasExisten) {
      console.error('‚ùå No se pudieron encontrar todos los canvas');
      return false;
    }

    // Configuraci√≥n base simplificada
    const configBase = {
      type: 'line',
      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: {
          duration: 0
        },
        scales: {
          x: {
            type: 'linear',
            position: 'bottom',
            title: {
              display: true,
              text: 'Tiempo'
            }
          },
          y: {
            beginAtZero: false,
            title: {
              display: true,
              text: 'Valor'
            }
          }
        },
        plugins: {
          legend: {
            display: true,
            position: 'top'
          }
        }
      }
    };

    // Crear datasets para cada sensor
    const datasets = Object.keys(coloresSensores).map(sensor => ({
      label: sensor,
      borderColor: coloresSensores[sensor],
      backgroundColor: coloresSensores[sensor] + '20',
      data: [],
      tension: 0.4,
      pointRadius: 3,
      pointHoverRadius: 6,
      fill: false
    }));

    // Inicializar gr√°ficos individualmente
    try {
      charts.temperatura = new Chart(
        document.getElementById('chartTemperatura').getContext('2d'),
        {
          ...configBase,
          data: { datasets: JSON.parse(JSON.stringify(datasets)) }
        }
      );
      console.log('‚úÖ Gr√°fico de temperatura inicializado');
    } catch (error) {
      console.error('‚ùå Error inicializando gr√°fico de temperatura:', error);
    }

    try {
      charts.humedad = new Chart(
        document.getElementById('chartHumedad').getContext('2d'),
        {
          ...configBase,
          data: { datasets: JSON.parse(JSON.stringify(datasets)) }
        }
      );
      console.log('‚úÖ Gr√°fico de humedad inicializado');
    } catch (error) {
      console.error('‚ùå Error inicializando gr√°fico de humedad:', error);
    }

    try {
      charts.presion = new Chart(
        document.getElementById('chartPresion').getContext('2d'),
        {
          ...configBase,
          data: { datasets: JSON.parse(JSON.stringify(datasets)) }
        }
      );
      console.log('‚úÖ Gr√°fico de presi√≥n inicializado');
    } catch (error) {
      console.error('‚ùå Error inicializando gr√°fico de presi√≥n:', error);
    }

    try {
      charts.viento = new Chart(
        document.getElementById('chartViento').getContext('2d'),
        {
          ...configBase,
          data: { datasets: JSON.parse(JSON.stringify(datasets)) }
        }
      );
      console.log('‚úÖ Gr√°fico de viento inicializado');
    } catch (error) {
      console.error('‚ùå Error inicializando gr√°fico de viento:', error);
    }

    // Verificar que todos los gr√°ficos se inicializaron
    const todosInicializados = Object.values(charts).every(chart => chart !== null);
    
    if (todosInicializados) {
      graficosListos = true;
      console.log('üéâ TODOS los gr√°ficos inicializados correctamente');
      return true;
    } else {
      console.error('‚ùå No todos los gr√°ficos se inicializaron');
      return false;
    }
  } catch (error) {
    console.error('‚ùå Error cr√≠tico inicializando gr√°ficos:', error);
    return false;
  }
}

// Actualizar m√©tricas actuales
function actualizarMetricas(datos) {
  datosCliente.metricasActuales[datos.sensorNombre] = datos;
  
  const metricasContainer = document.getElementById('metricasActuales');
  if (!metricasContainer) {
    console.error('‚ùå No se encontr√≥ el contenedor de m√©tricas');
    return;
  }
  
  metricasContainer.innerHTML = '';
  
  Object.values(datosCliente.metricasActuales).forEach(metricas => {
    const card = document.createElement('div');
    card.className = 'metric-card';
    card.style.background = `linear-gradient(135deg, ${coloresSensores[metricas.sensorNombre]} 0%, ${ajustarColor(coloresSensores[metricas.sensorNombre], -30)} 100%)`;
    
    card.innerHTML = `
      <h4>${metricas.sensorNombre}</h4>
      <div class="metric-value">${metricas.temperatura.toFixed(1)}¬∞C</div>
      <div class="metric-sensor">
        Hum: ${metricas.humedad}% | Pres: ${metricas.presion.toFixed(1)} hPa<br>
        Viento: ${metricas.viento.toFixed(1)} km/h
      </div>
    `;
    
    metricasContainer.appendChild(card);
  });
}

// Funci√≥n auxiliar para ajustar colores
function ajustarColor(color, cantidad) {
  // Convertir color HEX a RGB
  let r = parseInt(color.slice(1, 3), 16);
  let g = parseInt(color.slice(3, 5), 16);
  let b = parseInt(color.slice(5, 7), 16);

  // Ajustar brillo
  r = Math.max(0, Math.min(255, r + cantidad));
  g = Math.max(0, Math.min(255, g + cantidad));
  b = Math.max(0, Math.min(255, b + cantidad));

  // Convertir de vuelta a HEX
  return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;
}

// Actualizar gr√°ficos - VERSI√ìN MEJORADA
function actualizarGraficos(datos) {
  if (!graficosListos) {
    console.log('‚è≥ Gr√°ficos no listos, reintentando inicializaci√≥n...');
    if (inicializarGraficos()) {
      console.log('‚úÖ Gr√°ficos inicializados, procediendo con actualizaci√≥n');
    } else {
      console.error('‚ùå No se pudieron inicializar los gr√°ficos');
      return;
    }
  }

  const timestamp = Date.now(); // Usar timestamp simple
  
  // Actualizar cada gr√°fico con manejo de errores
  Object.keys(charts).forEach(tipo => {
    try {
      const chart = charts[tipo];
      
      if (!chart) {
        console.warn(`‚ö†Ô∏è Gr√°fico ${tipo} no est√° inicializado`);
        return;
      }
      
      const datasetIndex = chart.data.datasets.findIndex(ds => ds.label === datos.sensorNombre);
      
      if (datasetIndex !== -1) {
        // Agregar nuevo punto
        const valor = datos[tipo === 'viento' ? 'viento' : tipo];
        chart.data.datasets[datasetIndex].data.push({
          x: timestamp,
          y: valor
        });
        
        // Mantener √∫ltimos 20 puntos
        if (chart.data.datasets[datasetIndex].data.length > 20) {
          chart.data.datasets[datasetIndex].data.shift();
        }
        
        // Actualizar gr√°fico
        chart.update('none');
      }
    } catch (error) {
      console.error(`‚ùå Error actualizando gr√°fico ${tipo}:`, error);
    }
  });
}

// Actualizar mapa de calor
function actualizarHeatmap() {
  const heatmap = document.getElementById('heatmap');
  if (!heatmap) {
    console.error('‚ùå No se encontr√≥ el heatmap');
    return;
  }
  
  heatmap.innerHTML = '';
  
  Object.values(datosCliente.metricasActuales).forEach(datos => {
    const item = document.createElement('div');
    item.className = 'heatmap-item';
    
    // Calcular color basado en temperatura
    const temp = datos.temperatura;
    let color;
    if (temp < 15) color = '#4ECDC4'; // Fr√≠o
    else if (temp < 25) color = '#FFEAA7'; // Templado
    else color = '#FF6B6B'; // Caliente
    
    item.style.background = `linear-gradient(135deg, ${color} 0%, ${ajustarColor(color, -20)} 100%)`;
    
    item.innerHTML = `
      <div class="sensor-name">${datos.sensorNombre}</div>
      <div class="temp-value">${temp.toFixed(1)}¬∞C</div>
    `;
    
    heatmap.appendChild(item);
  });
}

// Eventos de Socket.IO
socket.on('datosHistoricos', (datos) => {
  console.log('üìä Datos hist√≥ricos recibidos');
});

socket.on('nuevosDatosClima', (datos) => {
  console.log('üì® Nuevos datos clim√°ticos:', datos.sensorNombre);
  
  actualizarMetricas(datos);
  actualizarGraficos(datos);
  actualizarHeatmap();
});

// Manejar errores de conexi√≥n
socket.on('connect_error', (error) => {
  console.error('‚ùå Error de conexi√≥n:', error);
});

// Inicializar la aplicaci√≥n cuando el DOM est√© completamente listo
document.addEventListener('DOMContentLoaded', () => {
  console.log('üîÑ Inicializando aplicaci√≥n IoT...');
  
  // Esperar un poco m√°s para asegurar que todo est√© renderizado
  setTimeout(() => {
    console.log('üéØ Intentando inicializar gr√°ficos...');
    if (inicializarGraficos()) {
      console.log('üöÄ Sistema IoT de monitoreo clim√°tico inicializado');
    } else {
      console.error('‚ùå Error cr√≠tico: No se pudieron inicializar los gr√°ficos');
      // Reintentar despu√©s de 1 segundo
      setTimeout(() => {
        console.log('üîÑ Reintentando inicializaci√≥n de gr√°ficos...');
        inicializarGraficos();
      }, 1000);
    }
  }, 1000);
});

// Manejar reconexiones de Socket.IO
socket.on('connect', () => {
  console.log('‚úÖ Conectado al servidor');
});

socket.on('disconnect', () => {
  console.log('‚ùå Desconectado del servidor');
});

// Manejar cierre de la p√°gina
window.addEventListener('beforeunload', () => {
  destruirGraficos();
});