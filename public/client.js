const socket = io();

// Configuraci√≥n de gr√°ficos
const charts = {
  temperatura: null,
  humedad: null,
  presion: null,
  viento: null
};

// Colores para diferentes sensores
const coloresSensores = {
  'Bogot√°': '#FF6B6B',
  'Medell√≠n': '#4ECDC4',
  'Cali': '#45B7D1',
  'Barranquilla': '#96CEB4',
  'Cartagena': '#FFEAA7'
};

// Datos en memoria del cliente
const datosCliente = {
  metricasActuales: {},
  historico: {
    temperatura: [],
    humedad: [],
    presion: [],
    viento: []
  }
};

// Bandera para verificar si los gr√°ficos est√°n listos
let graficosListos = false;
let inicializacionEnProgreso = false;

// Destruir gr√°ficos existentes
function destruirGraficos() {
  Object.keys(charts).forEach(tipo => {
    if (charts[tipo]) {
      charts[tipo].destroy();
      charts[tipo] = null;
    }
  });
  graficosListos = false;
}

// Inicializar gr√°ficos - VERSI√ìN CORREGIDA
function inicializarGraficos() {
  if (inicializacionEnProgreso) {
    console.log('üîÑ Inicializaci√≥n ya en progreso...');
    return false;
  }
  
  inicializacionEnProgreso = true;
  
  try {
    // Destruir gr√°ficos existentes primero
    destruirGraficos();

    // Verificar que los elementos canvas existan
    const canvasIds = ['chartTemperatura', 'chartHumedad', 'chartPresion', 'chartViento'];
    
    for (const canvasId of canvasIds) {
      const canvas = document.getElementById(canvasId);
      if (!canvas) {
        console.error(`‚ùå No se encontr√≥ el canvas: ${canvasId}`);
        inicializacionEnProgreso = false;
        return false;
      }
      // Limpiar el contexto del canvas
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    const configBase = {
      type: 'line',
      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: {
          duration: 0
        },
        scales: {
          x: {
            type: 'time',
            time: {
              unit: 'minute',
              displayFormats: {
                minute: 'HH:mm'
              }
            },
            title: {
              display: true,
              text: 'Tiempo'
            }
          },
          y: {
            beginAtZero: false,
            title: {
              display: true,
              text: 'Valor'
            }
          }
        },
        plugins: {
          legend: {
            display: true,
            position: 'top'
          }
        }
      }
    };

    // Inicializar gr√°ficos con IDs √∫nicos
    charts.temperatura = new Chart(
      document.getElementById('chartTemperatura').getContext('2d'),
      {
        ...configBase,
        data: {
          datasets: Object.keys(coloresSensores).map(sensor => ({
            label: sensor,
            borderColor: coloresSensores[sensor],
            backgroundColor: coloresSensores[sensor] + '20',
            data: [],
            tension: 0.4,
            pointRadius: 3,
            pointHoverRadius: 6,
            fill: false
          }))
        }
      }
    );

    charts.humedad = new Chart(
      document.getElementById('chartHumedad').getContext('2d'),
      {
        ...configBase,
        data: {
          datasets: Object.keys(coloresSensores).map(sensor => ({
            label: sensor,
            borderColor: coloresSensores[sensor],
            backgroundColor: coloresSensores[sensor] + '20',
            data: [],
            tension: 0.4,
            pointRadius: 3,
            pointHoverRadius: 6,
            fill: false
          }))
        }
      }
    );

    charts.presion = new Chart(
      document.getElementById('chartPresion').getContext('2d'),
      {
        ...configBase,
        data: {
          datasets: Object.keys(coloresSensores).map(sensor => ({
            label: sensor,
            borderColor: coloresSensores[sensor],
            backgroundColor: coloresSensores[sensor] + '20',
            data: [],
            tension: 0.4,
            pointRadius: 3,
            pointHoverRadius: 6,
            fill: false
          }))
        }
      }
    );

    charts.viento = new Chart(
      document.getElementById('chartViento').getContext('2d'),
      {
        ...configBase,
        data: {
          datasets: Object.keys(coloresSensores).map(sensor => ({
            label: sensor,
            borderColor: coloresSensores[sensor],
            backgroundColor: coloresSensores[sensor] + '20',
            data: [],
            tension: 0.4,
            pointRadius: 3,
            pointHoverRadius: 6,
            fill: false
          }))
        }
      }
    );

    graficosListos = true;
    inicializacionEnProgreso = false;
    console.log('‚úÖ Gr√°ficos inicializados correctamente');
    return true;
  } catch (error) {
    console.error('‚ùå Error inicializando gr√°ficos:', error);
    destruirGraficos();
    inicializacionEnProgreso = false;
    return false;
  }
}

// Actualizar m√©tricas actuales
function actualizarMetricas(datos) {
  datosCliente.metricasActuales[datos.sensorNombre] = datos;
  
  const metricasContainer = document.getElementById('metricasActuales');
  metricasContainer.innerHTML = '';
  
  Object.values(datosCliente.metricasActuales).forEach(metricas => {
    const card = document.createElement('div');
    card.className = 'metric-card';
    card.style.background = `linear-gradient(135deg, ${coloresSensores[metricas.sensorNombre]} 0%, ${ajustarColor(coloresSensores[metricas.sensorNombre], -30)} 100%)`;
    
    card.innerHTML = `
      <h4>${metricas.sensorNombre}</h4>
      <div class="metric-value">${metricas.temperatura.toFixed(1)}¬∞C</div>
      <div class="metric-sensor">
        Hum: ${metricas.humedad}% | Pres: ${metricas.presion.toFixed(1)} hPa<br>
        Viento: ${metricas.viento.toFixed(1)} km/h
      </div>
    `;
    
    metricasContainer.appendChild(card);
  });
}

// Funci√≥n auxiliar para ajustar colores
function ajustarColor(color, cantidad) {
  // Convertir color HEX a RGB
  let r = parseInt(color.slice(1, 3), 16);
  let g = parseInt(color.slice(3, 5), 16);
  let b = parseInt(color.slice(5, 7), 16);

  // Ajustar brillo
  r = Math.max(0, Math.min(255, r + cantidad));
  g = Math.max(0, Math.min(255, g + cantidad));
  b = Math.max(0, Math.min(255, b + cantidad));

  // Convertir de vuelta a HEX
  return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;
}

// Actualizar gr√°ficos - VERSI√ìN MEJORADA
function actualizarGraficos(datos) {
  // Si los gr√°ficos no est√°n listos, no intentar actualizar
  if (!graficosListos) {
    console.log('‚è≥ Gr√°ficos no listos, esperando inicializaci√≥n...');
    return;
  }

  const timestamp = new Date(datos.timestamp);
  
  // Actualizar cada gr√°fico con manejo de errores
  Object.keys(charts).forEach(tipo => {
    try {
      const chart = charts[tipo];
      
      if (!chart) {
        console.warn(`‚ö†Ô∏è Gr√°fico ${tipo} no est√° inicializado`);
        return;
      }
      
      const datasetIndex = chart.data.datasets.findIndex(ds => ds.label === datos.sensorNombre);
      
      if (datasetIndex !== -1) {
        // Agregar nuevo punto
        const valor = datos[tipo === 'viento' ? 'viento' : tipo];
        chart.data.datasets[datasetIndex].data.push({
          x: timestamp,
          y: valor
        });
        
        // Mantener √∫ltimos 20 puntos
        if (chart.data.datasets[datasetIndex].data.length > 20) {
          chart.data.datasets[datasetIndex].data.shift();
        }
        
        // Actualizar gr√°fico suavemente
        chart.update('none');
      }
    } catch (error) {
      console.error(`‚ùå Error actualizando gr√°fico ${tipo}:`, error);
    }
  });
}

// Actualizar mapa de calor
function actualizarHeatmap() {
  const heatmap = document.getElementById('heatmap');
  heatmap.innerHTML = '';
  
  Object.values(datosCliente.metricasActuales).forEach(datos => {
    const item = document.createElement('div');
    item.className = 'heatmap-item';
    
    // Calcular color basado en temperatura
    const temp = datos.temperatura;
    let color;
    if (temp < 15) color = '#4ECDC4'; // Fr√≠o
    else if (temp < 25) color = '#FFEAA7'; // Templado
    else color = '#FF6B6B'; // Caliente
    
    item.style.background = `linear-gradient(135deg, ${color} 0%, ${ajustarColor(color, -20)} 100%)`;
    
    item.innerHTML = `
      <div class="sensor-name">${datos.sensorNombre}</div>
      <div class="temp-value">${temp.toFixed(1)}¬∞C</div>
    `;
    
    heatmap.appendChild(item);
  });
}

// Eventos de Socket.IO - VERSI√ìN MEJORADA
socket.on('datosHistoricos', (datos) => {
  console.log('üìä Datos hist√≥ricos recibidos');
  // Aqu√≠ puedes procesar datos hist√≥ricos si es necesario
});

socket.on('nuevosDatosClima', (datos) => {
  console.log('üì® Nuevos datos clim√°ticos:', datos.sensorNombre);
  
  actualizarMetricas(datos);
  actualizarGraficos(datos);
  actualizarHeatmap();
});

// Manejar errores de conexi√≥n
socket.on('connect_error', (error) => {
  console.error('‚ùå Error de conexi√≥n:', error);
});

// Inicializar la aplicaci√≥n cuando el DOM est√© completamente listo
document.addEventListener('DOMContentLoaded', () => {
  console.log('üîÑ Inicializando aplicaci√≥n IoT...');
  
  // Esperar a que todos los elementos est√©n renderizados
  setTimeout(() => {
    if (inicializarGraficos()) {
      console.log('üöÄ Sistema IoT de monitoreo clim√°tico inicializado');
    } else {
      console.error('‚ùå Error cr√≠tico: No se pudieron inicializar los gr√°ficos');
      // Reintentar despu√©s de 2 segundos
      setTimeout(() => {
        console.log('üîÑ Reintentando inicializaci√≥n de gr√°ficos...');
        inicializarGraficos();
      }, 2000);
    }
  }, 500);
});

// Manejar reconexiones de Socket.IO
socket.on('connect', () => {
  console.log('‚úÖ Conectado al servidor');
});

socket.on('disconnect', () => {
  console.log('‚ùå Desconectado del servidor');
});

// Manejar cierre de la p√°gina
window.addEventListener('beforeunload', () => {
  destruirGraficos();
});